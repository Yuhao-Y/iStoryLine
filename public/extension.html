<!DOCTYPE html>
<meta charset="utf-8">
<style>

.node {
  stroke-width: 1.5px;
}

</style>
<body>
<script src="http://d3js.org/d3.v3.min.js"></script>

<script>

var width = 960,
    height = 500;

var fill = d3.scale.category10();

var nodes = new Array();

var scenesNumber = 1;

var scene = parent.scenes[scenesNumber-1];

var characterMap = parent.characterMap;

var characterNodeMap = new Map();

characterMap.forEach(function (value, key, map) {
    var node = {};
    node.x = 10;
    node.y = 10;
    node.value = value;
    node.id = key;
    //nodes.push(node);
    characterNodeMap.set(key, node);
});

createGroupFromScene(scene, scenesNumber);

console.log(nodes);

var force = d3.layout.force()
    .nodes(nodes)
    .size([width, height])
    .on("tick", tick)
    .chargeDistance(500)
    .start();

var svg = d3.select("body").append("svg")
    .attr("width", width)
    .attr("height", height);

var node = svg.selectAll(".node")
    .data(nodes)
    .enter().append("circle")
    .attr("class", "node")
    .attr("cx", function(d) { return d.x; })
    .attr("cy", function(d) { return d.y; })
    .attr("r", 12)
    .style("fill", function(d, i) { return d.value.color; })
    .style("stroke", function(d, i) { return d3.rgb(d.value.color).darker(2); })
    .call(force.drag)
    .on("mousedown", function() { d3.event.stopPropagation(); });

svg.style("opacity", 1e-6)
    .transition()
    .duration(1000)
    .style("opacity", 1);

d3.select("body")
    .on("mousedown", mousedown);

function tick(e) {

  // Push different nodes in different directions for clustering.
  var k = 6 * e.alpha;

  // nodes.forEach(function(o, i) {
  //   if(o.id == 'R2D' || o.id == 'DV1') {
  //     o.y += 0.05;
  //     o.x += 0.0;
  //   } else if(o.id == 'TEST1'){
  //     o.y += 0.1;
  //     o.x += 0.0;
  //   } else {
  //     o.y += -0.15;
  //     o.x += -0.0;
  //   }

  // });

  createGroupFromScene(scene, scenesNumber)

  node.attr("cx", function(d) { return d.x; })
      .attr("cy", function(d) { return d.y; });
}

function mousedown() {
  nodes.forEach(function(o, i) {
    o.x += (Math.random() - .5) * 40;
    o.y += (Math.random() - .5) * 40;
  });
  force.resume();
}

function createGroupFromScene(scene, scenesNumber) {
  var characterGroupMap = new Map();
  var groupCoordinateMap = new Map();

  if(scene.hasOwnProperty("groups") == true){
    for(var i = 0; i < scene.groups.length; i++) {
      var coordinate = {};
      coordinate.x = Math.random();
      coordinate.y = Math.random();

       groupCoordinateMap.put(i, coordinate);

       scene.groups[i].character.forEach(function(c) {
        characterGroupMap.put(c, i);
       })
    }
  }

  characterNodeMap.forEach(function (node, key, map) {
    console.log(node);
    if (node.value.startTimestamp <= scenesNumber && node.value.endTimestamp >= scenesNumber && nodes.indexOf(node) == -1) { 
      nodes.push(node);
    } else if(node.value.startTimestamp > scenesNumber || node.value.endTimestamp < scenesNumber && nodes.indexOf(node) >= 0) {
      var index = nodes.indexOf(node);
      nodes.splice(index, 1);
    }
  });



  nodes.forEach(function(node) {
    if (characterGroupMap.has(node.id)) {
      var coordinate = groupCoordinateMap.get(characterGroupMap.get(node.id));

      node.x = coordinate.x; 
      node.y = coordinate.y;
    } else {
      node.x = Math.random();
      node.y = Math.random();
    }


  });

}

</script>